# setup all the imports
from pathlib import Path  # noqa: E402

from extremeweatherbench import cases, defaults, evaluate, inputs, metrics

# make the basepath - change this to your local path
basepath = Path.home() / "extreme-weather-bench-paper" / ""
basepath = str(basepath) + "/"

from dataclasses import dataclass

import pandas as pd
import xarray as xr
from arraylake import Client


@dataclass
class ArraylakeForecast(inputs.ForecastBase):
    prefetch: bool = True

    def _prefetch_data(self):
        client = Client()
        repo = client.get_repo(f"{self.org_name}/{self.repo_name}")
        session = repo.readonly_session(self.branch_name)
        self.ds = xr.open_zarr(session.store, group=self.group_name)
        self.ds = self.ds.assign_coords(
            {"lead_time": self.ds.lead_time.astype("timedelta64[h]")}
        )

    def __post_init__(self):
        # source should be like arraylake://org_name/repo_name@branch_name/group/name/goes/here
        if not self.source.startswith("arraylake://"):
            raise ValueError("source must start with arraylake://")
        bits = self.source.split("://")[1].split("/")
        self.org_name = bits[0]
        if "@" not in bits[1]:
            self.branch_name = "main"
            self.repo_name = bits[1]
        else:
            self.repo_name, self.branch_name = bits[1].split("@")
        self.group_name = "/".join(bits[2:])
        if self.prefetch:
            self._prefetch_data()

    def _open_data_from_source(self) -> xr.Dataset:
        if self.ds is None:
            self._prefetch_data()
        return self.ds


# setup the templates to load in the data

# Forecast Examples
cira_freeze_forecast_FOURv2_IFS = inputs.KerchunkForecast(
    source="gs://extremeweatherbench/FOUR_v200_IFS.parq",
    variables=["surface_air_temperature"],
    variable_mapping={"t2": "surface_air_temperature"},
    storage_options={"remote_protocol": "s3", "remote_options": {"anon": True}},
    preprocess=defaults._preprocess_bb_cira_forecast_dataset,
    name="CIRA FOURv2 IFS",
)

cira_freeze_forecast_GC_IFS = inputs.KerchunkForecast(
    source="gs://extremeweatherbench/GRAP_v100_IFS.parq",
    variables=["surface_air_temperature"],
    variable_mapping={"t2": "surface_air_temperature"},
    storage_options={"remote_protocol": "s3", "remote_options": {"anon": True}},
    preprocess=defaults._preprocess_bb_cira_forecast_dataset,
    name="CIRA GC IFS",
)

cira_freeze_forecast_PANG_IFS = inputs.KerchunkForecast(
    source="gs://extremeweatherbench/PANG_v100_IFS.parq",
    variables=["surface_air_temperature"],
    variable_mapping={"t2": "surface_air_temperature"},
    storage_options={"remote_protocol": "s3", "remote_options": {"anon": True}},
    preprocess=defaults._preprocess_bb_cira_forecast_dataset,
    name="CIRA PANG IFS",
)

cira_freeze_forecast_FOURv2_GFS = inputs.KerchunkForecast(
    source="gs://extremeweatherbench/FOUR_v200_GFS.parq",
    variables=["surface_air_temperature"],
    variable_mapping={"t2": "surface_air_temperature"},
    storage_options={"remote_protocol": "s3", "remote_options": {"anon": True}},
    preprocess=defaults._preprocess_bb_cira_forecast_dataset,
    name="CIRA FOURv2 GFS",
)

cira_freeze_forecast_GC_GFS = inputs.KerchunkForecast(
    source="gs://extremeweatherbench/GRAP_v100_GFS.parq",
    variables=["surface_air_temperature"],
    variable_mapping={"t2": "surface_air_temperature"},
    storage_options={"remote_protocol": "s3", "remote_options": {"anon": True}},
    preprocess=defaults._preprocess_bb_cira_forecast_dataset,
    name="CIRA GC GFS",
)

cira_freeze_forecast_PANG_GFS = inputs.KerchunkForecast(
    source="gs://extremeweatherbench/PANG_v100_GFS.parq",
    variables=["surface_air_temperature"],
    variable_mapping={"t2": "surface_air_temperature"},
    storage_options={"remote_protocol": "s3", "remote_options": {"anon": True}},
    preprocess=defaults._preprocess_bb_cira_forecast_dataset,
    name="CIRA PANG GFS",
)

hres_forecast = inputs.ZarrForecast(
    source="gs://weatherbench2/datasets/hres/2016-2022-0012-1440x721.zarr",
    variables=["surface_air_temperature"],
    variable_mapping=inputs.HRES_metadata_variable_mapping,
    storage_options={"remote_options": {"anon": True}},
    name="ECMWF HRES",
)

bb_hres_forecast = ArraylakeForecast(
    source="arraylake://brightband/ecmwf@main/forecast-archive/ewb-hres",
    variables=["surface_air_temperature"],
    variable_mapping={
        "t2m": "surface_air_temperature",
    },
    name="ECMWF HRES, Brightband mirror",
)


freeze_metrics = [
    metrics.MinimumMeanAbsoluteError,
    metrics.RootMeanSquaredError,
]

BB_HRES_FREEZE_EVALUATION_OBJECTS = [
    inputs.EvaluationObject(
        event_type="freeze",
        metric_list=freeze_metrics,
        target=defaults.era5_freeze_target,
        forecast=bb_hres_forecast,
    ),
    inputs.EvaluationObject(
        event_type="freeze",
        metric_list=freeze_metrics,
        target=defaults.ghcn_freeze_target,
        forecast=bb_hres_forecast,
    ),
]


FOURv2_FREEZE_EVALUATION_OBJECTS = [
    inputs.EvaluationObject(
        event_type="freeze",
        metric_list=freeze_metrics,
        target=defaults.ghcn_heatwave_target,
        forecast=cira_freeze_forecast_FOURv2_IFS,
    ),
    inputs.EvaluationObject(
        event_type="freeze",
        metric_list=freeze_metrics,
        target=defaults.ghcn_heatwave_target,
        forecast=cira_freeze_forecast_FOURv2_GFS,
    ),
    inputs.EvaluationObject(
        event_type="freeze",
        metric_list=freeze_metrics,
        target=defaults.era5_heatwave_target,
        forecast=cira_freeze_forecast_FOURv2_IFS,
    ),
    inputs.EvaluationObject(
        event_type="freeze",
        metric_list=freeze_metrics,
        target=defaults.era5_heatwave_target,
        forecast=cira_freeze_forecast_FOURv2_GFS,
    ),
]

GC_FREEZE_EVALUATION_OBJECTS = [
    inputs.EvaluationObject(
        event_type="freeze",
        metric_list=freeze_metrics,
        target=defaults.ghcn_heatwave_target,
        forecast=cira_freeze_forecast_GC_IFS,
    ),
    inputs.EvaluationObject(
        event_type="freeze",
        metric_list=freeze_metrics,
        target=defaults.ghcn_heatwave_target,
        forecast=cira_freeze_forecast_GC_GFS,
    ),
    inputs.EvaluationObject(
        event_type="freeze",
        metric_list=freeze_metrics,
        target=defaults.era5_heatwave_target,
        forecast=cira_freeze_forecast_GC_IFS,
    ),
    inputs.EvaluationObject(
        event_type="freeze",
        metric_list=freeze_metrics,
        target=defaults.era5_heatwave_target,
        forecast=cira_freeze_forecast_GC_GFS,
    ),
]

PANG_FREEZE_EVALUATION_OBJECTS = [
    inputs.EvaluationObject(
        event_type="freeze",
        metric_list=freeze_metrics,
        target=defaults.ghcn_heatwave_target,
        forecast=cira_freeze_forecast_PANG_IFS,
    ),
    inputs.EvaluationObject(
        event_type="freeze",
        metric_list=freeze_metrics,
        target=defaults.ghcn_heatwave_target,
        forecast=cira_freeze_forecast_PANG_GFS,
    ),
    inputs.EvaluationObject(
        event_type="freeze",
        metric_list=freeze_metrics,
        target=defaults.era5_heatwave_target,
        forecast=cira_freeze_forecast_PANG_IFS,
    ),
    inputs.EvaluationObject(
        event_type="freeze",
        metric_list=freeze_metrics,
        target=defaults.era5_heatwave_target,
        forecast=cira_freeze_forecast_PANG_GFS,
    ),
]

HRES_FREEZE_EVALUATION_OBJECTS = [
    inputs.EvaluationObject(
        event_type="freeze",
        metric_list=freeze_metrics,
        target=defaults.ghcn_heatwave_target,
        forecast=hres_forecast,
    ),
    inputs.EvaluationObject(
        event_type="freeze",
        metric_list=freeze_metrics,
        target=defaults.era5_heatwave_target,
        forecast=hres_forecast,
    ),
]

# load in all of the events in the yaml file
ewb_cases = cases.load_ewb_events_yaml_into_case_collection()
ewb_cases = ewb_cases.select_cases("event_type", "freeze")

early_cases = cases.IndividualCaseCollection(
    [i for i in ewb_cases.cases if i.end_date < pd.Timestamp("2023-01-01")]
)
later_cases = cases.IndividualCaseCollection(
    [i for i in ewb_cases.cases if i.start_date > pd.Timestamp("2023-01-01")]
)

ewb_hres_early = evaluate.ExtremeWeatherBench(
    early_cases, HRES_FREEZE_EVALUATION_OBJECTS
)
ewb_hres_later = evaluate.ExtremeWeatherBench(
    later_cases, BB_HRES_FREEZE_EVALUATION_OBJECTS
)


# ewb_fourv2 = evaluate.ExtremeWeatherBench(ewb_cases, FOURv2_FREEZE_EVALUATION_OBJECTS)
# ewb_gc = evaluate.ExtremeWeatherBench(ewb_cases, GC_FREEZE_EVALUATION_OBJECTS)
# ewb_pang = evaluate.ExtremeWeatherBench(ewb_cases, PANG_FREEZE_EVALUATION_OBJECTS)
ewb_hres = evaluate.ExtremeWeatherBench(ewb_cases, HRES_FREEZE_EVALUATION_OBJECTS)


# load in the results for all heat waves in parallel
# this will take awhile to run if you do them all in one code box
# if you have already saved them (from running this once), then skip this box
parallel_config = {"backend": "loky", "n_jobs": 32}

# fourv2_results = ewb_fourv2.run(parallel_config=parallel_config)
# gc_results = ewb_gc.run(parallel_config=parallel_config)
# pang_results = ewb_pang.run(parallel_config=parallel_config)
hres_results = ewb_hres_early.run(parallel_config=parallel_config)
bb_hres_results = ewb_hres_later.run(parallel_config=parallel_config)
hres_results = pd.concat([hres_results, bb_hres_results])

# save the results to make it more efficient
print("saving results to pickle")
# fourv2_results.to_pickle(basepath + "saved_data/fourv2_freeze_results.pkl")
# gc_results.to_pickle(basepath + "saved_data/gc_freeze_results.pkl")
# pang_results.to_pickle(basepath + "saved_data/pang_freeze_results.pkl")
hres_results.to_pickle(basepath + "saved_data/hres_freeze_results.pkl")
print("results saved")
